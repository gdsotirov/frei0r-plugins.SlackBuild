# Fix compatibility with OpenCV 3.0
# See https://build.opensuse.org/package/view_file/home:alarrosa:branches:Factory-KDE5:Applications/frei0r-plugins/frei0r-plugins-openCV-3.0-compatibility.patch?expand=1
diff -urNad frei0r-plugins-1.4-orig/src/filter/facedetect/facedetect.c frei0r-plugins-1.4/src/filter/facedetect/facedetect.c
--- frei0r-plugins-1.4-orig/src/filter/facedetect/facedetect.c	2013-02-24 15:43:22.000000000 +0200
+++ frei0r-plugins-1.4/src/filter/facedetect/facedetect.c	1970-01-01 02:00:00.000000000 +0200
@@ -1,266 +0,0 @@
-/**
- * binarymillenium 2007
- *
- * This code is released under the GPL
- *
- * *
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <assert.h>
-#include <math.h>
-#include <float.h>
-#include <limits.h>
-#include <time.h>
-#include <ctype.h>
-
-
-#include "cv.h"
-//#include "highgui.h"
-
-#include "frei0r.h"
-
-#ifdef _EiC
-#define WIN32
-#endif
-
-
-CvSeq* detect_and_draw( IplImage* img, CvMemStorage* storage,
-                        CvHaarClassifierCascade* cascade);
-
-#ifndef OPENCV_PREFIX
-#error OPENCV_PREFIX must contain the installation prefix of OpenCV
-#endif
-
-#define STR(x) #x
-#define TOSTR(x) STR(x)
-
-static const char* const cascade_name =
-   TOSTR(OPENCV_PREFIX)"/share/opencv/haarcascades/haarcascade_frontalface_alt2.xml";
-/*    "haarcascade_frontalface_alt.xml";*/
-/*    "haarcascade_profileface.xml";*/
-
-
-typedef struct facedetect_instance{
-
-  IplImage *frame, *frame_copy;
-
-  int width;
-  int height;
-
-  CvMemStorage* storage;
-  CvHaarClassifierCascade* cascade;
-
-} facedetect_instance_t;
-
-int f0r_init()
-{
-  return 1;
-}
-
-f0r_instance_t f0r_construct(unsigned int width, unsigned int height)
-{
-  facedetect_instance_t* inst =
-    (facedetect_instance_t*)malloc(sizeof(facedetect_instance_t));
-
-  inst->width = width;
-  inst->height = height;
-
-  /// tbd - put this in init instead?
-  inst->storage = 0;
-  inst->cascade = 0;
-
-  inst->frame = 0;
-  inst->frame_copy = 0;
-
-  inst->cascade = (CvHaarClassifierCascade*)cvLoad( cascade_name, 0, 0, 0 );
-    
-  if( !inst->cascade )
-    {
-      fprintf(stderr, "ERROR: Could not load classifier cascade %s\n",
-              cascade_name);
-      free(inst);
-      return (f0r_instance_t)0;
-    }
-  else
-    {
-      inst->storage = cvCreateMemStorage(0);
-
-      //cvNamedWindow( "result", 1 );
-
-      return (f0r_instance_t)inst;
-    }
-}
-
-
-void f0r_deinit()
-{
-}
-
-void f0r_destruct(f0r_instance_t instance)
-{
-  free(instance);
-  //cvDestroyWindow("result");
-}
-
-void f0r_set_param_value(f0r_instance_t instance,
-                         f0r_param_t param, int param_index)
-{
-}
-
-void f0r_get_param_value(f0r_instance_t instance,
-                         f0r_param_t param, int param_index)
-{
-}
-
-void f0r_get_plugin_info(f0r_plugin_info_t* facedetectInfo)
-{
-  facedetectInfo->name = "opencvfacedetect";
-  facedetectInfo->author = "binarymillenium";
-  facedetectInfo->plugin_type = F0R_PLUGIN_TYPE_FILTER;
-  facedetectInfo->color_model = F0R_COLOR_MODEL_BGRA8888;
-  facedetectInfo->frei0r_version = FREI0R_MAJOR_VERSION;
-  facedetectInfo->major_version = 0;
-  facedetectInfo->minor_version = 1;
-  facedetectInfo->num_params =  1;
-  facedetectInfo->explanation = "detect faces";
-}
-
-void f0r_get_param_info(f0r_param_info_t* info, int param_index)
-{
-  switch(param_index)
-    {
-    case 0:
-      info->name = "test";
-      info->type = F0R_PARAM_DOUBLE;
-      info->explanation = "test";
-      break;
-    }
-
-}
-
-void f0r_update(f0r_instance_t instance, double time,
-                const uint32_t* inframe, uint32_t* outframe)
-{
-  assert(instance);
-
-  facedetect_instance_t* inst = (facedetect_instance_t*)instance;
-
-  unsigned char* dst = (unsigned char*)outframe;
-  const unsigned char* src = (unsigned char*)inframe;
-
-
-  if( !inst->frame_copy )
-    inst->frame_copy = cvCreateImage( cvSize(inst->width,inst->height),
-                                      IPL_DEPTH_8U, 4 );
-
-  unsigned char* ipli = (unsigned char*)inst->frame_copy->imageData;
-  int step = inst->frame_copy->widthStep;
-  unsigned i, j;
-  for (i = 0; (i < inst->height); i++) {
-    for (j = 0; (j < inst->width); j++) {
-      ipli[i*step+j*4+2] = src[2];
-      ipli[i*step+j*4+1] = src[1];
-      ipli[i*step+j*4+0] = src[0];
-
-      //ipli += 4;
-      src += 4;
-
-    }
-
-  }
-
-  /*CvSeq* faces =*/ detect_and_draw( inst->frame_copy,
-                                  inst->storage,
-                                  inst->cascade );
-
-  ipli = (unsigned char*)inst->frame_copy->imageData;
-
-  for (i = 0; (i < inst->height); i++) {
-    for (j = 0; (j < inst->width); j++) {
-      dst[2] = ipli[2];
-      dst[1] = ipli[1];
-      dst[0] = ipli[0];
-
-      ipli += 4;
-      dst += 4;
-    }
-  }
-
-  cvReleaseImage( &(inst->frame_copy) );
-
-}
-
-CvSeq* detect_and_draw( IplImage* img, CvMemStorage* storage,
-                        CvHaarClassifierCascade* cascade)
-{
-  static CvScalar colors[] =
-    {
-      {{255,255,255}},
-      {{0,128,255}},
-      {{0,255,255}},
-      {{0,255,0}},
-      {{255,128,0}},
-      {{255,255,0}},
-      {{255,0,0}},
-      {{255,0,255}},
-      {{0,0,0}}
-    };
-
-  double scale = 1.3;
-  IplImage* gray = cvCreateImage( cvSize(img->width,img->height), 8, 1 );
-  IplImage* small_img = cvCreateImage( cvSize( cvRound (img->width/scale),
-                                               cvRound (img->height/scale)),
-                                       8, 1 );
-  int i;
-
-  cvCvtColor( img, gray, CV_BGR2GRAY );
-  cvResize( gray, small_img, CV_INTER_LINEAR );
-  cvEqualizeHist( small_img, small_img );
-  //cvClearMemStorage( storage );
-
-  CvSeq* faces = 0;
-
-  if( cascade )
-    {
-      double t = (double)cvGetTickCount();
-      faces = cvHaarDetectObjects( small_img, cascade, storage,
-                                   1.1, 2, 0/*CV_HAAR_DO_CANNY_PRUNING*/,
-                                   cvSize(30, 30) );
-      t = (double)cvGetTickCount() - t;
-      //printf( "detection time = %gms\n", t/((double)cvGetTickFrequency()*1000.) );
-
-      CvPoint pt1, pt2;
-      pt1.x = 0;
-      pt1.y = 0;
-      pt2.x = img->width;
-      pt2.y = img->height;
-      cvRectangle( img, pt1, pt2, colors[8],CV_FILLED, 8, 0 );
-
-      for( i = 0; i < (faces ? faces->total : 0); i++ )
-        {
-          CvRect* r = (CvRect*)cvGetSeqElem( faces, i );
-          CvPoint center;
-          int radius;
-          center.x = cvRound((r->x + r->width*0.5)*scale);
-          center.y = cvRound((r->y + r->height*0.5)*scale);
-          radius = cvRound((r->width + r->height)*0.25*scale);
-
-          pt1.x = r->x;// - r->width*0.5; 
-          pt1.y = r->y;// - r->height*0.5; 
-          pt2.x = r->x + r->width;
-          pt2.y = r->y + r->height;
-          //printf( " faces %d %d \n",  center.x, center.y);
-          cvCircle( img, center, radius, colors[i%8],CV_FILLED, 8, 0); // 3, 8, 0 );
-          //cvRectangle( img, pt1, pt2, colors[i%8], CV_FILLED );
-        }
-    }
-
-  //cvShowImage( "result", img );
-  cvReleaseImage( &gray );
-  cvReleaseImage( &small_img );
-
-  return faces;
-}
diff -urNad frei0r-plugins-1.4-orig/src/filter/facedetect/facedetect.cpp frei0r-plugins-1.4/src/filter/facedetect/facedetect.cpp
--- frei0r-plugins-1.4-orig/src/filter/facedetect/facedetect.cpp	2013-02-24 15:43:22.000000000 +0200
+++ frei0r-plugins-1.4/src/filter/facedetect/facedetect.cpp	2016-09-15 20:27:12.000000000 +0300
@@ -25,7 +25,7 @@
 #include <limits.h>
 #include <time.h>
 #include <ctype.h>
-#include <opencv/cv.h>
+#include <opencv/cv.hpp>
 #include "frei0r.hpp"
 #include "frei0r_math.h"
 
@@ -259,11 +259,19 @@
     {
         double scale = this->scale == 0? 1.0 : this->scale;
         CvScalar colors[5] = {
+#if defined(CV_MAJOR_VERSION) && (CV_MAJOR_VERSION >= 3)
+            CvScalar(cvRound(color[0].r * 255), cvRound(color[0].g * 255), cvRound(color[0].b * 255), cvRound(alpha * 255)),
+            CvScalar(cvRound(color[1].r * 255), cvRound(color[1].g * 255), cvRound(color[1].b * 255), cvRound(alpha * 255)),
+            CvScalar(cvRound(color[2].r * 255), cvRound(color[2].g * 255), cvRound(color[2].b * 255), cvRound(alpha * 255)),
+            CvScalar(cvRound(color[3].r * 255), cvRound(color[3].g * 255), cvRound(color[3].b * 255), cvRound(alpha * 255)),
+            CvScalar(cvRound(color[4].r * 255), cvRound(color[4].g * 255), cvRound(color[4].b * 255), cvRound(alpha * 255)),
+#else
             {{cvRound(color[0].r * 255), cvRound(color[0].g * 255), cvRound(color[0].b * 255), cvRound(alpha * 255)}},
             {{cvRound(color[1].r * 255), cvRound(color[1].g * 255), cvRound(color[1].b * 255), cvRound(alpha * 255)}},
             {{cvRound(color[2].r * 255), cvRound(color[2].g * 255), cvRound(color[2].b * 255), cvRound(alpha * 255)}},
             {{cvRound(color[3].r * 255), cvRound(color[3].g * 255), cvRound(color[3].b * 255), cvRound(alpha * 255)}},
             {{cvRound(color[4].r * 255), cvRound(color[4].g * 255), cvRound(color[4].b * 255), cvRound(alpha * 255)}},
+#endif
         };
         
         for (int i = 0; i < (objects ? objects->total : 0); i++)
@@ -287,14 +295,23 @@
                 }
             case 1:
                 {
+#if defined(CV_MAJOR_VERSION) && (CV_MAJOR_VERSION >= 3)
+                    CvBox2D box = CvBox2D(CvPoint2D32f(center.x, center.y), CvSize2D32f(r->width / scale, (r->height / scale) * 1.2), 90);
+#else
                     CvBox2D box = {{center.x, center.y}, {r->width / scale, (r->height / scale) * 1.2}, 90};
+#endif
                     cvEllipseBox(image, box, colors[i % 5], thickness, linetype);
                     break;
                 }
             case 2:
                 {
+#if defined(CV_MAJOR_VERSION) && (CV_MAJOR_VERSION >= 3)
+                    CvPoint pt1 = CvPoint(r->x / scale, r->y / scale);
+                    CvPoint pt2 = CvPoint((r->x + r->width) / scale, (r->y + r->height) / scale);
+#else
                     CvPoint pt1 = {r->x / scale, r->y / scale};
                     CvPoint pt2 = {(r->x + r->width) / scale, (r->y + r->height) / scale};
+#endif
                     cvRectangle(image, pt1, pt2, colors[i % 5], thickness, linetype);
                     break;
                 }
